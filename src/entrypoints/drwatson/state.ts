import type { FunctionComponent } from "preact";
import { signal } from "@preact/signals";
import { gensym } from ".././../utils/gensym";
import type { Data } from "./datatypes";

type Empty = { [key: string]: never };

// When an analyzer is instantiated, it will be stacked onto the global stack frame.
// So that users may "undo" their analysis by poping out a stack frame.
// The top (0-th) frame in the stack is called "active frame" in this repo.
//
// * id
//   An unique id, generated by "gensym" util.
//
// * component
//   A preact component with no props.
//   Each analyzer modules may return a component to be rendered, if needed.
//   The component usually include kinda "control panel" to configure the module instance.
//   Local state of each analyzer module must be encapsulated in a think (closure).
//
// * label
//   An user-friendly description of the stack frame.
//   Usually derived from the module description.
//
// * result
//   The latest output from the analyzer module instance.
//   This may be null until the first output.
//   Note that result of inactive (intermediate) frames cannot be updated.
//
// [Technical notes]
//
// Due to lack of existential types in TypeScript, we cannot store local states
// in a serializable form like below.
//
//   StackFrame = exists T. { state: T, component: FunctionComponent<T>, ... }
//   Stack = StackFrame[]
//
// So I decided to encapusulate (hide) local states in their thunks.
//
//   StackFrame = { component: FunctionComponent<Empty>, ... }
//
// Note that a non-existential type like below
//
//   AModuleFrame = { state: AState, component: FunctionComponent<AState>, ... }
//   BModuleFrame = { state: BState, component: FunctionComponent<AState>, ... }
//   StackFrame = AModuleInstance | BModuleInstance | ...
//
// is NOT polymorphic enough to avoid type puzzles.
//
// see also https://zenn.dev/uhyo/articles/existential-capsule
//
export type StackFrame = {
  id: number,
  component?: FunctionComponent<Empty>,
  label: string,
  result: Data | null,
};

// A module will receive following props when instantiated.
//
// * id
//   An unique id, generated by "gensym" util.
//
// * src
//   The last output from the previous module.
//
// And returns
//
// * initialResult
//   Optional initial output (if analysis is done synchronously during initialization).
//
// * component
//   Optional component to put into the stack frame with his local state .
//
// Note that both can be updated later (as long as the module is active).
//
export type AnalyzerModule = {
  // An user-friendly description.
  label: string,
  // Check if the module is applicable to a data, and returns an explanation if true.
  // Note that this procedure should return as fast as possible to avoid input lags.
  detect: (suspicious: Data) => string | null,
  instantiate: (src: Data, id: number) => {
    initialResult?: Data,
    component?: FunctionComponent<Empty>,
  },
};

// Importer modules are just like analyzer modules, but they are not given SRC data.
export type ImporterModule = {
  label: string,
  instantiate: (id: number) => {
    initialResult?: Data,
    component?: FunctionComponent<Empty>,
  },
};

// ----

                             export const busy = signal(false);
export const stack = signal<StackFrame[]>([]);

// Mark the active module as busy (or not busy).
export const setBusy = (id: number, value: boolean) => {
  if (id === stack.value[0]?.id) {
    busy.value = value;
  }
};

// Update the active module's output.
export const updateResult = (id: number, result: Data) => {
  const _stack = stack.peek(); // do not subscribe, to avoid infinite loops
  if (id === _stack[0]?.id) {
    stack.value = [{ ..._stack[0], result }, ..._stack.slice(1)];
  }
};

// Update the active module's component.
export const updateComponent = (id: number, component: FunctionComponent<Empty>) => {
  const _stack = stack.peek(); // do not subscribe, to avoid infinite loops
  if (id === _stack[0]?.id) {
    stack.value = [{ ..._stack[0], component }, ..._stack.slice(1)];
  }
};

// Initialize an importer and the stack.
export const setImporter = (module: ImporterModule) => {
  busy.value = false;
  const id = gensym();
  const { initialResult, component } = module.instantiate(id);
  stack.value = [{ id, component, label: module.label, result: initialResult ?? null }];
};

// Initialize an analyzer and push on to the stack.
export const pushAnalyzer = (module: AnalyzerModule) => {
  const _stack = stack.peek(); // do not subscribe, to avoid infinite loops
  if (!_stack[0]?.result) {
    throw new Error("UNEXPECTED: cannot analyze null output");
  }
  busy.value = false;
  const id = gensym();
  const src = _stack[0].result;
  const { initialResult, component } = module.instantiate(src, id);
  stack.value = [
    { id, component, label: module.label, result: initialResult ?? null },
    ..._stack,
  ];
};

// An exceptional frame which is not related to any modules.
// This may used to inspect a single element in a set of data.
export const pushInspection = (data: Data) => {
  busy.value = false;
  const id = gensym();
  const _stack = stack.peek(); // do not subscribe, to avoid infinite loops
  stack.value = [
    { id, label: "この項目を精査", result: data },
    ..._stack,
  ];
};

// Pop out (at most) N frames to undo.
export const undo = (n: number) => {
  const _stack = stack.peek(); // do not subscribe, to avoid infinite loops
  busy.value = false;
  stack.value = _stack.slice(n);
};

// Pop out all frames to reset state.
export const reset = () => {
  stack.value = [];
};
